# 02. 산술 연산자

```java
public class Main {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;

        byte c = a + b; // compile error
    }
}
```

위 코드에서 `byte`타입 변수끼리의 연산임에도 불구하고 컴파일 에러가 발생한다.<br>
그 이유는 산술 변환에서 보았던 것처럼, `int`보다 작은 범위인 `byte`간 연산에서 `int`로 자동 형변환 되었기에 a + b가 `int`타입이 된 것이기 때문이다.

---

```java
public class Main {
    public static void main(String[] args) {
        int a = 1_000_000;
        int b = 2_000_000;

        long c = a * b;

        System.out.println(c); // -1454759936
    }
}
```

`1,000,000` * `2,000,000`의 연산 결과는 8Byte인 `long`타입의 저장 공간에 충분히 저장될 것 같지만<br>
결과는 전혀 다른 값이 출력된다. 이유는 `int`타입인 `a`, `b`간의 연산이기에 결과도 `int`타입이 되기 때문이다.<br>

a * b의 값이 `int`로 계산되어 `-1454759936`가 되었고<br>
이를 `long` 타입인 `c`에 넣는다 해도 `-1454759936` 값이 유지된 것이다.

// 올바른 결과를 위해 ```long c = (long)a * b;```

아래는  이와 비슷한 예시이다.

```java
public class Main {
    public static void main(String[] args) {
        long a = 1_000_000 * 1_000_000;
        long b = 1_000_000 * 1_000_000L;

        System.out.println(a); // -727379968
        System.out.println(b); // 1000000000000
    }
}
```

---

뿐만 아니라 산술 연산의 순서에 따라서도 결과가 달라지는 경우가 존재한다.

```java
public class Main {
    public static void main(String[] args) {
        int a = 1000000;

        int res1 = a * a / a;
        int res2 = a / a * a;

        System.out.println(res1); // -727
        System.out.println(res2); // 1000000
    }
}
```

`res1`의 경우 `a * a` 연산을 먼저 수행한다. 이에 `1000000000000` 결과, 즉 오버플로우가 발생하여 올바른 결과 값이 나오지 않은 것이다.<br>
반면 `res2`의 경우 `1000000 / 1000000 = 1`이 되어 `int` 범위 내에서 올바른 연산이 가능하다.
